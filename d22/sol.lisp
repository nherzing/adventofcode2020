(defpackage :d22
  (:use :common-lisp :common))

(defparameter *lines* (read-lines "input.txt"))

(defun score (deck)
  (format t "~a~%" deck)
  (reduce #'+ (mapcar #'* (reverse deck) (upto (1+ (length deck)) :min 1))))

(defun play (p1-deck p2-deck)
  (let ((p1-deck (copy-seq p1-deck))
        (p2-deck (copy-seq p2-deck)))
    (loop
      (cond ((= 0 (length p1-deck))
             (return (score p2-deck)))
            ((= 0 (length p2-deck))
             (return (score p1-deck)))
            ((> (car p1-deck) (car p2-deck))
             (let* ((higher (pop p1-deck))
                    (lower (pop p2-deck))
                    (new-p1-deck (reverse (cons lower (cons higher (reverse p1-deck))))))
               (setf p1-deck new-p1-deck)))
            ((> (car p2-deck) (car p1-deck))
             (let* ((higher (pop p2-deck))
                    (lower (pop p1-deck))
                    (new-p2-deck (reverse (cons lower (cons higher (reverse p2-deck))))))
               (setf p2-deck new-p2-deck)))))))

(defun solve ()
  (let* ((parts (split-at "" *lines* :test 'equal))
         (p1-deck (mapcar #'parse-integer (rest (first parts))))
         (p2-deck (mapcar #'parse-integer (rest (second parts)))))
    (play p1-deck p2-deck)
    (format t "~a~%" p1-deck)))

(defun playr (orig-p1-deck orig-p2-deck)
;;  (format t "PLAY:~%P1: ~a~%P2: ~a~%~%" orig-p1-deck orig-p2-deck)
  (let ((p1-deck (copy-seq orig-p1-deck))
        (p2-deck (copy-seq orig-p2-deck))
        (seen (make-hash-table :test 'equal)))
    (loop
      (when (gethash (list p1-deck p2-deck) seen)
;;        (format t "EARLY EXIT: ~a, ~a~%" p1-deck p2-deck)
        (return 'p1))
      (setf (gethash (list p1-deck p2-deck) seen) t)
;;      (format t "LOOP:~%P1: ~a~%P2: ~a~%~%" p1-deck p2-deck)
      (cond ((= 0 (length p1-deck))
             (return (values 'p2 p2-deck)))
            ((= 0 (length p2-deck))
             (return (values 'p1 p1-deck)))
            ((let ((p1-top (car p1-deck))
                   (p2-top (car p2-deck)))
               (and (> (length p1-deck) (car p1-deck))
                    (> (length p2-deck) (car p2-deck))))
             (let* ((p1-top (car p1-deck))
                    (p2-top (car p2-deck))
                    (new-p1-deck (subseq p1-deck 1 (1+ p1-top)))
                    (new-p2-deck (subseq p2-deck 1 (1+ p2-top)))
                    (winner (playr new-p1-deck new-p2-deck)))
               (setf (gethash (list new-p1-deck new-p2-deck) seen) winner)
               (if (eq winner 'p1)
                   (let* ((higher (pop p1-deck))
                          (lower (pop p2-deck))
                          (new-p1-deck (reverse (cons lower (cons higher (reverse p1-deck))))))
                     (setf p1-deck new-p1-deck))
                   (let* ((higher (pop p2-deck))
                          (lower (pop p1-deck))
                          (new-p2-deck (reverse (cons lower (cons higher (reverse p2-deck))))))
                     (setf p2-deck new-p2-deck)))))
            ((> (car p1-deck) (car p2-deck))
             (let* ((higher (pop p1-deck))
                    (lower (pop p2-deck))
                    (new-p1-deck (reverse (cons lower (cons higher (reverse p1-deck))))))
               (setf p1-deck new-p1-deck)))
            ((> (car p2-deck) (car p1-deck))
             (let* ((higher (pop p2-deck))
                    (lower (pop p1-deck))
                    (new-p2-deck (reverse (cons lower (cons higher (reverse p2-deck))))))
               (setf p2-deck new-p2-deck)))))))

(defun solve2 ()
  (let* ((parts (split-at "" *lines* :test 'equal))
         (p1-deck (mapcar #'parse-integer (rest (first parts))))
         (p2-deck (mapcar #'parse-integer (rest (second parts)))))
    (multiple-value-bind (winner deck) (playr p1-deck p2-deck)
      (score deck))))
