(defpackage :d14
  (:use :common-lisp :common))

(defparameter *lines* (read-lines "input.txt"))

(defclass program ()
  ((ones-mask :initform nil :accessor ones-mask)
   (zeros-mask :initform nil :accessor zeros-mask)
   (memory :initform (make-hash-table) :reader memory)))

(defun set-mask (program mask)
  (let ((one-mask '())
        (zero-mask '()))
    (dolist (c (coerce mask 'list))
      (cond ((char= c #\X)
             (push #\0 one-mask)
             (push #\0 zero-mask))
            ((char= c #\1)
             (push #\1 one-mask)
             (push #\0 zero-mask))
            ((char= c #\0)
             (push #\0 one-mask)
             (push #\1 zero-mask))))
    (setf (ones-mask program) (parse-integer (coerce (reverse one-mask) 'string) :radix 2))
    (setf (zeros-mask program) (parse-integer (coerce (reverse zero-mask) 'string) :radix 2))
;;    (format t "mask = ~a 0s: ~a 1s: ~a~%" mask (zeros-mask program) (ones-mask program))
    ))

(defun set-val (program addr val)
;;  (format t "mem[~a] = ~a~%" addr val)
  (let ((mem (memory program)))
    (setf (gethash addr mem)
          (logior (logand val (lognot (zeros-mask program))) (ones-mask program)))
;;    (loop for k being the hash-keys in (memory program) using (hash-value v)
;;          do (format t "~a => ~a~%" k v))
    ))

(defun handle-line (line program)
  (if (string= "mask" (subseq line 0 4))
      (set-mask program (subseq line 7))
      (let* ((addr-end (search "]" line))
            (addr (parse-integer (subseq line 4 addr-end)))
            (val-start (search "=" line))
            (val (parse-integer (subseq line (+ 2 val-start)))))
        (set-val program addr val))))

(defun solve ()
  (let ((program (make-instance 'program)))
    (dolist (line *lines*)
      (handle-line line program))
;;    (loop for k being the hash-keys in (memory program) using (hash-value v)
;;          do (format t "~a => ~a~%" k v))
    (loop for key being the hash-keys of (memory program) summing (gethash key (memory program)))))

(defclass program2 ()
  ((mask :initform nil :accessor mask)
   (memory :initform (make-hash-table) :reader memory)))

(defun set-mask2 (program mask)
  (setf (mask program) mask))

(defun apply-mask (mask addr)
  (let ((baddr (format nil "~36,'0B" addr)))
    (coerce (mapcar #'(lambda (ac mc)
                        (cond ((char= #\0 mc) ac)
                              ((char= #\1 mc) #\1)
                              ((char= #\X mc) #\X)))
                    (coerce baddr 'list) (coerce  mask 'list))
            'string)))

(defun build-perms (masked-addr)
  (let ((first-x (position #\X masked-addr)))
    (if first-x
        (append
         (build-perms (substitute #\0 #\X (copy-seq masked-addr) :count 1))
         (build-perms (substitute #\1 #\X (copy-seq masked-addr) :count 1)))
        (list (parse-integer masked-addr :radix 2)))))

(defun get-addrs (program addr)
  (let ((masked-addr (apply-mask (mask program) addr)))
    (build-perms masked-addr)))

(defun set-val2 (program addr val)
  (let ((addrs (get-addrs program addr))
        (mem (memory program)))
    (dolist (addr addrs)
      (setf (gethash addr mem) val))))

(defun handle-line2 (line program)
  (if (string= "mask" (subseq line 0 4))
      (set-mask2 program (subseq line 7))
      (let* ((addr-end (search "]" line))
             (addr (parse-integer (subseq line 4 addr-end)))
             (val-start (search "=" line))
             (val (parse-integer (subseq line (+ 2 val-start)))))
        (set-val2 program addr val))))


(defun solve2 ()
  (let ((program (make-instance 'program2)))
    (dolist (line *lines*)
      (handle-line2 line program))
    ;;    (loop for k being the hash-keys in (memory program) using (hash-value v)
    ;;          do (format t "~a => ~a~%" k v))
    (loop for key being the hash-keys of (memory program) summing (gethash key (memory program)))))
