(defpackage :d20
  (:use :common-lisp :common))

(defparameter *lines* (read-lines "input.txt"))

(defun parse-row (piece)
  piece)
  ;; (list (first piece)
  ;;       (parse-integer
  ;;        (coerce (mapcar #'(lambda (c) (if (char= c #\#) #\1 #\0)) (second piece)) 'string)
  ;;        :radix 2)
  ;;       ))

(defun parse-piece (raw-piece)
  (let* ((id (parse-integer (string-left-trim "Tile " (string-right-trim ":" (first raw-piece)))))
         (rows (mapcar #'(lambda (row) (coerce row 'list)) (rest raw-piece)))
         (top  (first rows))
         (bottom (first (last rows)))
         (left (mapcar #'(lambda (row) (nth 0 row)) rows))
         (right (mapcar #'(lambda (row) (nth (1- (length row)) row)) rows)))
    (list id
          (mapcar #'parse-row
                  (list (list '(top   nil) top)
                        (list '(top   t) (reverse top))
                        (list '(bot   nil) bottom)
                        (list '(bot   t) (reverse bottom))
                        (list '(right nil) right)
                        (list '(right t) (reverse right))
                        (list '(left  nil) left)
                        (list '(left  t) (reverse left))))
          rows
          )))

(defun parse-pieces (raw-pieces)
  (mapcar #'parse-piece raw-pieces))

(defun build-common-sides (pieces)
  (let ((common-sides (make-hash-table :test 'equal)))
    (dolist (piece pieces)
      (let ((id (first piece))
            (sides (second piece)))
        (dolist (side sides)
          (push (list id (first side)) (gethash (second side) common-sides)))))
    common-sides))

(defun cornerp (piece common-sides)
  (= (count-if (exterior-side-p common-sides) (second piece))
     4))

(defun exterior-side-p (common-sides)
  #'(lambda (side) (= (length (gethash (second side) common-sides)) 1)))

(defun flippedp (side)
  (second (first side)))

(defun non-flipped-sides (sides)
  (remove-if #'flippedp sides))

;; result flips are horizontal, flip first then rotate -> (rotations, h-flip?)
(defun transform-to-top (start-side)
  (cond ((equal start-side '(right nil)) '(3 nil))
        ((equal start-side '(top   nil)) '(0 nil))
        ((equal start-side '(left  nil)) '(3 t  ))
        ((equal start-side '(bot   nil)) '(2 t  ))
        ((equal start-side '(right t  )) '(1 t  ))
        ((equal start-side '(top   t  )) '(0 t  ))
        ((equal start-side '(left  t  )) '(1 nil))
        ((equal start-side '(bot   t  )) '(2 nil))))

;; result flips are horizontal, flip first then rotate -> (rotations, h-flip?)
(defun transform-to-left (start-side)
  (cond ((equal start-side '(right nil)) '(0 t  ))
        ((equal start-side '(top   nil)) '(3 t  ))
        ((equal start-side '(left  nil)) '(0 nil))
        ((equal start-side '(bot   nil)) '(1 nil))
        ((equal start-side '(right t  )) '(2 nil))
        ((equal start-side '(top   t  )) '(3 nil))
        ((equal start-side '(left  t  )) '(2 t  ))
        ((equal start-side '(bot   t  )) '(1 t  ))))


(defun transform-coord (xy trans &key (dim 10))
  (let ((x (first xy))
        (y (second xy))
        (rots (first trans))
        (h-flip (second trans)))
    (dotimes (r (- 4 rots))
      (let ((tx x))
        (setf x (- (1- dim) y)
              y tx)))
    (if h-flip (setf x (- (1- dim) x)))
    (list x y)))

(defun upto (max &key (min 0))
  (loop for i from min to (1- max) collecting i))

(defun get-in-trans-piece (trans-piece xy)
;;  (format t "get-in-trans-piece ~a~%" xy)
;;  (format t "~a~%" (third (first trans-piece)))
  (let* ((new-xy (transform-coord xy (second trans-piece)))
         (x (first new-xy))
         (y (second new-xy)))
;;    (format t "getting ~a,~a~%" x y)
    (nth x (nth y (third (first trans-piece))))))


(defun bottom-after-transform (trans-piece)
  (mapcar #'(lambda (x) (get-in-trans-piece trans-piece (list x 9))) (upto 10)))

(defun right-after-transform (trans-piece)
  (mapcar #'(lambda (y) (get-in-trans-piece trans-piece (list 9 y))) (upto 10)))

(defun build-puzzle (upper-left-corner-piece pieces common-sides dim)
  (let (
        (interior-sides (remove-if (exterior-side-p common-sides) (non-flipped-sides (second upper-left-corner-piece)))))
    (format t "interior sides: ~a~%" interior-sides))
  (let ((trans-upper-left-corner-piece (list upper-left-corner-piece '(0 nil)))
        (puzzle (make-hash-table :test 'equal)))
    (format t "Upper left: ~a~%" trans-upper-left-corner-piece)
    (setf (gethash '(0 0) puzzle) trans-upper-left-corner-piece)
    (loop for y from 1 to (1- dim) do
      (let* ((trans-bottom-left-piece (gethash (list 0 (1- y)) puzzle))
             (new-bottom (bottom-after-transform trans-bottom-left-piece))
             (all-matching-edges (gethash new-bottom common-sides))
             (matching-edge (first (remove (first (first trans-bottom-left-piece)) (gethash new-bottom common-sides) :key #'first)))
             (trans-for-new-bottom (transform-to-top (second matching-edge))))
        (setf (gethash (list 0 y) puzzle) (list (find (first matching-edge) pieces :key #'first) trans-for-new-bottom))
        (format t "~%place 0,~a~%" y)
        (format t "new bottom: ~a~%" new-bottom)
        (format t "all matching edges: ~a~%" all-matching-edges)
        (format t "matching edge: ~a ~a~%" matching-edge trans-for-new-bottom)))
    (dolist (y (upto dim))
      (dolist (x (upto dim :min 1))
        (let* ((trans-left-of (gethash (list (1- x) y) puzzle))
               (new-right (right-after-transform trans-left-of))
               (matching-edge (first (remove (first (first trans-left-of)) (gethash new-right common-sides) :key #'first)))
               (trans-for-new-right (transform-to-left (second matching-edge))))
          (setf (gethash (list x y) puzzle) (list (find (first matching-edge) pieces :key #'first) trans-for-new-right))
          (format t "place ~a,~a~%" x y)
          (format t "new right: ~a~%" new-right)
          (format t "matching edge: ~a ~a~%" matching-edge trans-for-new-right))))
    puzzle))

(defun build-full-grid (placed-pieces dim)
  (mapcar #'(lambda (y)
              (let ((py (floor (/ y 8))))
                (mapcar #'(lambda (x)
                            (let* ((px (floor (/ x 8)))
                                   (trans-piece (gethash (list px py) placed-pieces)))
                              (get-in-trans-piece trans-piece (list (1+ (mod x 8)) (1+ (mod y 8))))))
                        (upto (* dim 8)))))
          (upto (* dim 8))))

(defun format-grid (grid dim transform)
  (dolist (y (upto dim))
    (dolist (x (upto dim))
      (let ((nxy (transform-coord (list x y) transform :dim dim)))
        (format t "~a" (nth (first nxy) (nth (second nxy) grid)))))
    (format t "~%"))
  (format t "~%"))

(defparameter *monster*
  '((18 0)
    (0 1) (5 1) (6 1) (11 1) (12 1) (17 1) (18 1) (19 1)
    (1 2) (4 2) (7 2) (10 2) (13 2) (16 2)
    ))

(defparameter *transforms*
  '((0 nil) (1 nil) (2 nil) (3 nil) (0 t) (1 t) (2 t) (3 t)))

;;"                  #"
;;"#    ##    ##    ###"
;;" #  #  #  #  #  #"

(defun sea-monster-p (grid xy transform)
  (let* ((txy (funcall transform xy))
         (start-x (first txy))
         (start-y (second txy))
         (end-xy (funcall transform (list (+ (first xy) 18) (+ (second xy) 2)))))
    (and (< 0 (first end-xy) (length (first grid)))
         (< 0 (second end-xy) (length grid))
         (every #'(lambda (monster-xy)
                    (let ((txy (funcall transform (list (+ (first monster-xy) (first xy))
                                                        (+ (second monster-xy) (second xy))))))
                      (char= #\# (nth (first txy) (nth (second txy) grid))))) *monster*))))

(defun sea-monster-coords (xy transform)
  (let* ((txy (funcall transform xy))
         (start-x (first txy))
         (start-y (second txy)))
    (mapcar #'(lambda (monster-xy) (funcall transform (list (+ (first monster-xy) (first xy))
                                                            (+ (second monster-xy) (second xy)))))
            *monster*)))

(defun coords (dim)
  (let ((result '()))
    (dolist (x (upto dim))
      (dolist (y (upto dim))
        (push (list x y) result)))
    result))

(defun get-xs (grid dim)
  (let ((result (make-hash-table :test 'equal)))
    (dolist (x (upto dim))
      (dolist (y (upto dim))
        (if (char= #\# (nth x (nth y grid)))
            (setf (gethash (list x y) result) t))))
    result))

(defun solve ()
  (let* ((raw-pieces (split-at "" *lines* :test #'string=))
         (pieces (parse-pieces raw-pieces))
         (dim (floor (sqrt (length pieces))))
         (common-sides (build-common-sides pieces))
         (corners (remove-if-not #'(lambda (piece) (cornerp piece common-sides)) pieces))
         (placed-pieces (build-puzzle (fourth corners) pieces common-sides dim))
         (grid (build-full-grid placed-pieces dim)))
    (format-grid grid (* 8 dim) '(3 t))
    (mapcar #'(lambda (transform)
                (let* ((transform-fun #'(lambda (xy)
                                         (transform-coord xy transform :dim (* 8 dim))))
                       (monster-coords (remove-if-not
                                        #'(lambda (xy) (sea-monster-p grid xy transform-fun))
                                        (coords (* 8 dim)))))
                  (when (> (length monster-coords) 1)
                    (let ((all-xs (get-xs grid (* 8 dim))))
                      (dolist (mc monster-coords)
                        (dolist (mcxy (sea-monster-coords mc transform-fun))
                          (remhash mcxy all-xs)))
                      (loop for k being the hash-keys in all-xs count 1)))))
                  *transforms*)))

;; (fourth corners), '(0 nil)
;; (first corners),  '(2 t)
